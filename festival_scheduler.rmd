```{r knitr_options,include=F,eval=T,cache=F}
#######################
# general information #
#######################

# file:         festival_scheduler.rmd
# created:      2015-07-23
# last update:  2016-08-01
# author(s):    Marcel Schilling <marcel.schilling@mdc-berlin.de> (MS),
#               Filippos Klironomos <filippos.klironomos@mdc-berlin.de> (FK)
# license:      GNU Affero General Public License Version 3 (GNU AGPL v3)
# purpose:      generate running orders based on ratings


######################################
# change log (reverse chronological) #
######################################

# 2016-08-01: added rating column to personal running orders
# 2016-07-31: added sorting of gigs by start (needed for previous bug fix to work)
#             fixed long gigs overlapping short better gigs
# 2016-01-16: stopped running scheduler without full-information gigs
#             fixed knitr chunk option lists ('result' --> 'results' / removed superfluous ';')
#             added personal running orders (most code written already in 2015-07)
# 2015-07-27: added group running order
#             fixed typo in comment
#             added splitting of table structure into non-redundant sets for processing
# 2015-07-26: added date/time formatting for output table
#             converted score for output to percent
#             added date/time parsing
#             added rounding of numbers in table
#             removed second definition of live.counts.cols (copy/paste error)
# 2015-07-23: removed superfluous loading of unused plyr library
#             initial version (reproduce spreadsheet table)


#################
# knitr options #
#################

# define default working directory to use absolute paths in resulting Markdown (if not defined in
# knit'ing R session)
if(!exists("working_directory")){
  working_directory <- getwd()
} else {

  # remove final slash from working directory defined in the knit'ing R session
  working_directory <- sub("/$","",working_directory)

  # set working directory to the one defined in the knit'ing R session
  setwd(working_directory)
}

# set knitr options as suggested by FK
opts_knit$set(width          = 150,
              self.contained = T
             )

# set code chunks options as suggested by FK
opts_chunk$set(comment    = NA,
               tidy       = F,
               highlight  = T,
               prompt     = T,
               fig.path   = paste(working_directory,"knitr/figures/",sep="/"),
               fig.keep   = "high",
               fig.show   = "asis",
               background = "#F5F5DC",
               echo       = F,
               cache      = F,
               cache.path = paste(working_directory,"knitr/cache/",sep="/"),
               message    = F,
               warning    = F,
               error      = F
              )

# adjust output format for inline code chunks to use a thousands separator
knit_hooks$set(inline = function(output) ifelse(is.numeric(output),prettyNum(output,big.mark=','),output))

# set non-knitr options in another code chunk as suggested by FK
```

```{r r_options,include=F,eval=T,cache=F}
#############
# R options #
#############

# set options as suggested by FK
options(width=150, digits=10)
options(stringsAsFactors=F)
```

```{r parameters,include=F,eval=T,cache=F}
##############
# parameters #
##############

# define default (absolute) path of TSV file with rating table (if not defined in the knit'ing R
# session)
if(!exists("table_tsv")) table_tsv<-paste0(working_directory,"/table.tsv")

# define default rating-to-score mapping (if not defined in the knit'ing R session)
if(!exists("rating2score")) rating2score<-c('---'=-3
                                           , '--'=-2
                                           ,  '-'=-1
                                           ,  '?'= 1
                                           ,  '+'= 2
                                           , '++'= 3
                                           ,'+++'= 5
                                           )


# define default rounding precision for numbers in output table (if not defined in the knit'ing R
# session)
if(!exists("digits.table")) digits.table<-2

# define default strptime format for date/time strings in input table (if not defined in the
# knit'ing R session)
if(!exists("format.datetime.input")) format.datetime.input<-"%F %R"

# define default strftime format for date/time strings in output table (if not defined in the
# knit'ing R session)
if(!exists("format.datetime.output")) format.datetime.output<-"%F %R"

# define default time zone (if not defined in the knit'ing R session)
if(!exists("timezone")) timezone<-"GMT"
```


```{r libraries,include=F,eval=T,cache=F}
#############
# libraries #
#############

# use efficient apply functions
require(plyr)


#############
# functions #
#############

# define each function in its own cached code chunk to allow dependence on those chunks to force
# re-evaluation of chached code chunks using the function in case the function gets modified.
```

```{r function.live_count2score,include=F,eval=T}
# calculate live score based on live count & rating score
live_count2score<-function(live_count,rating_score)
                    ifelse(rating_score>1
                          ,ifelse(live_count<6
                                 ,rating_score-live_count
                                 ,rating_score-sqrt(live_count-5)-5
                                 )
                          ,ifelse(rating_score<0
                                 ,(live_count-.5)*rating_score
                                 ,0
                                 )
                          )
```

```{r read_table}
##################
# get input data #
##################

# read table TSV
tab<-read.table(table_tsv,sep="\t",header=T,quote="\"",na.strings=c("","NA"))
```

```{r parse_datetime}
tab$start<-strptime(tab$start,format.datetime.input,timezone)
tab$end<-strptime(tab$end,format.datetime.input,timezone)
```

```{r remove_nas}
# replace missing ratings with '?'
rating.cols<-grep("rating.",colnames(tab),fixed=T,value=T)
tab[,rating.cols][is.na(tab[,rating.cols])]<-"?"

# get group members
members<-sub("rating.","",rating.cols)

# replace missing live counts with 0
live_count.cols<-paste0("live_count.",members)
tab[,live_count.cols][is.na(tab[,live_count.cols])]<-0
```

```{r untable}
# get bands
bands<-sort(unique(tab$band))

# identify first entry per band
bands.rows<-laply(bands,function(band) which(tab$band==band)[1])

# get ratings
ratings<-setNames(data.frame(tab[bands.rows,rating.cols],row.names=bands),members)

# get live counts
live_counts<-setNames(data.frame(tab[bands.rows,live_count.cols],row.names=bands),members)

# get gigs
gigs<-tab[order(tab$start),c("band","stage","start","end")]
```

```{r get_scores}
###############
# score bands #
###############

# get ratings scores
rating_scores<-data.frame(do.call(cbind
                                 ,llply(ratings
                                       ,'['
                                       ,x=rating2score
                                       )
                                 )
                         ,row.names=bands
                         )

# get live scores
live_scores<-setNames(data.frame(do.call(cbind
                                        ,llply(members
                                              ,function(member)
                                                  live_count2score(live_counts[,member]
                                                                  ,rating_scores[,member]
                                                                  )
                                              )
                                        )
                                ,row.names=bands
                                )
                     ,members
                     )

# get total scores
total_scores<-rating_scores+live_scores

# normalize scores
normalization.sums<-rowSums(total_scores)
scores<-(normalization.sums-min(normalization.sums))/(max(normalization.sums)-min(normalization.sums))


################
# write output #
################
```
# Festival schedule

## Lineup table

For now, the festival scheduler simply reproduces the spreadsheet table:

```{r print_table,results="asis"}
# assemble output table converting date/times to strings & scores to percent
tab<-with(gigs
         ,data.frame(band
                    ,setNames(ratings[band,],paste0("rating.",members))
                    ,setNames(live_counts[band,],paste0("live_count.",members))
                    ,score=paste0(round(scores[band],digits.table)*100,"%")
                    ,stage
                    ,start=strftime(start,format.datetime.output)
                    ,end=strftime(end,format.datetime.output)
                    )
         )

# replace missing values with "tbc"
tab[is.na(tab)]<-"tbc"

# print table sorted by score
kable(tab[order(scores[gigs$band]
               ,decreasing=T
               )
         ,
         ]
     ,digits=digits.table
     ,row.names=F
     )
```

```{r check.run_scheduler}
# discard gigs with missing information
gigs<-gigs[!unlist(alply(gigs[,c("band","start","end")],1,anyNA)),]

# only run scheduler if there is at least one gig with full information
if(nrow(gigs)==0) knit_exit()
```

```{r schedule}
# identify all time intervals with different gig combinations
times<-sort(with(gigs,c(start,end)))
intervals<-unique(ldply(1:sum(times<tail(times,1))
                       ,function(begin)
                          data.frame(interval.begin=times[begin]
                                    ,interval.end=times[times>times[begin]][1]
                                    )
                       )
                 )
# identify corresponding gigs
intervals<-alply(intervals
                ,1
                ,with
                ,list(interval.begin=interval.begin
                     ,interval.end=interval.end
                     ,interval.gigs=which(gigs$start<=interval.begin&gigs$end>=interval.end)
                     )
                )

# discard intervals without gigs
intervals<-intervals[llply(intervals,with,length(interval.gigs))!=0]

# order interval gigs by scores & add personal rankings
intervals<-llply(intervals
                ,with
                ,list(interval.begin=interval.begin
                     ,interval.end=interval.end
                     ,interval.gigs=interval.gigs[order(scores[gigs$band[interval.gigs]]
                                                       ,decreasing=T
                                                       )
                                                 ]
                     ,personal.gigs=setNames(do.call(data.frame
                                                    ,llply(members
                                                          ,function(member)
                                                              interval.gigs[order(total_scores[gigs$band[interval.gigs]
                                                                                              ,member
                                                                                              ]
                                                                                  ,decreasing=T
                                                                                  )
                                                                           ]
                                                          )
                                                    )
                                            ,members
                                            )
                     )
                )
```

## Running order

### Group running order

For now, only the group running oder is generated:

```{r print_running_order,results="asis"}
# select top scored band per interval
running_order<-ldply(intervals
                    ,with
                    ,data.frame(start=interval.begin
                               ,end=interval.end
                               ,interval.gig=interval.gigs[1]
                               ,band=gigs$band[interval.gigs][1]
                               ,stage=gigs$stage[interval.gigs][1]
                               )
                    ,.id=NULL
                    )

# merge intervals with same gig
running_order<-ddply(running_order
                    ,.(interval.gig)
                    ,with
                    ,data.frame(start=min(start)
                               ,end=max(end)
                               ,band=band[1]
                               ,stage=stage[1]
                               )
                    )

# sort gigs by start time
running_order<-running_order[order(running_order$start),]

# split long gigs overlapping better short gigs
interval<-1
while(interval<nrow(running_order)){
  if(with(running_order
         ,end[interval]>start[interval+1]
         )
    ){
    running_order<<-rbind(running_order[1:(interval-1),]
                         ,with(running_order[interval+(0:1),]
                              ,data.frame(interval.gig=c(interval.gig,interval.gig[1])
                                         ,start=c(start,end[2])
                                         ,end=c(start[2],rev(end))
                                         ,band=c(band,band[1])
                                         ,stage=c(stage,stage[1])
                                         )
                              )
                         ,running_order[(interval+2):nrow(running_order),]
                         )
    interval<-interval+2
   }else{
    interval<-interval+1
   }
}
rm(interval)

# print running order converting date/times to string & adding scores
kable(with(running_order
          ,data.frame(start=strftime(start,format.datetime.output)
                     ,end=strftime(end,format.datetime.output)
                     ,band
                     ,stage
                     ,score=paste0(round(scores[band],digits.table)*100,"%")
                     )
           )
     )
```

```{r get.personal_running_orders}
# selet top scored band per group member & interval
personal_running_orders<-setNames(llply(members
                                       ,function(member){
                                          ldply(intervals
                                               ,function(interval)
                                                  with(interval
                                                      ,data.frame(start=interval.begin
                                                                 ,end=interval.end
                                                                 ,interval.gig=personal.gigs[1,member]
                                                                 ,band=gigs$band[personal.gigs[1,member]]
                                                                 ,stage=gigs$stage[personal.gigs[1,member]]
                                                                 )
                                                      )
                                               ,.id=NULL
                                               )
                                        }
                                       )
                                 ,members
                                 )

# merge intervals with same gig
personal_running_orders<-setNames(llply(members
                                 ,function(member)
                                    ddply(personal_running_orders[[member]]
                                         ,.(interval.gig)
                                         ,with
                                         ,data.frame(start=min(start)
                                                    ,end=max(end)
                                                    ,band=band[1]
                                                    ,stage=stage[1]
                                                    )
                                         )
                                 )
                           ,members
                           )

# sort gigs by start time
personal_running_orders<-llply(personal_running_orders
                              ,function(personal_running_order)
                                 personal_running_order[order(personal_running_order$start),]
                              )

# split long gigs overlapping better short gigs
l_ply(members
     ,function(member){
        interval<-1
        while(interval<nrow(personal_running_orders[[member]])){
          if(with(personal_running_orders[[member]]
                 ,end[interval]>start[interval+1]
                 )
            ){
            personal_running_orders[[member]]<<-rbind(personal_running_orders[[member]][1:(interval-1),]
                                                     ,with(personal_running_orders[[member]][interval+(0:1),]
                                                          ,data.frame(interval.gig=c(interval.gig,interval.gig[1])
                                                                     ,start=c(start,end[2])
                                                                     ,end=c(start[2],rev(end))
                                                                     ,band=c(band,band[1])
                                                                     ,stage=c(stage,stage[1])
                                                                     )
                                                          )
                                                     ,personal_running_orders[[member]][(interval+2):nrow(personal_running_orders[[member]]),]
                                                     )
            interval<-interval+2
           }else{
            interval<-interval+1
           }
        }
      }
     )
```

### Personal Running orders

```{r print.personal_running_orders,results="asis"}
# print running order for each member
l_ply(members
     ,function(member){

       # prepend running order with member name
       cat(paste0("\n#### ",member,"\n\n"))

       # print running order converting date/times to string & adding scores
       print(kable(with(personal_running_orders[[member]]
                     ,data.frame(start=strftime(start
                                               ,format.datetime.output
                                               )
                                ,end=strftime(end
                                             ,format.datetime.output
                                             )
                                ,band
                                ,stage
                                ,rating=ratings[band,member]
                                ,score=paste0(round(scores[band]
                                                   ,digits.table
                                                   )*100
                                             ,"%"
                                             )
                                )
                     )
                )
          )
      }
     )
```
