```{r knitr_options,include=F,eval=T,cache=F}
#######################
# general information #
#######################

# file:         festival_scheduler.rmd
# created:      2015-07-23
# last update:  2016-01-16
# author(s):    Marcel Schilling <marcel.schilling@mdc-berlin.de> (MS),
#               Filippos Klironomos <filippos.klironomos@mdc-berlin.de> (FK)
# license:      GNU Affero General Public License Version 3 (GNU AGPL v3)
# purpose:      generate running orders based on ratings


######################################
# change log (reverse chronological) #
######################################

# 2016-01-16: added personal running orders (most code written already in 2015-07)
# 2015-07-27: added group running order
#             fixed typo in comment
#             added splitting of table structure into non-redundant sets for processing
# 2015-07-26: added date/time formatting for output table
#             converted score for output to percent
#             added date/time parsing
#             added rounding of numbers in table
#             removed second definition of live.counts.cols (copy/paste error)
# 2015-07-23: removed superfluous loading of unused plyr library
#             initial version (reproduce spreadsheet table)


#################
# knitr options #
#################

# define default working directory to use absolute paths in resulting Markdown (if not defined in
# knit'ing R session)
if(!exists("working_directory")){
  working_directory <- getwd()
} else {

  # remove final slash from working directory defined in the knit'ing R session
  working_directory <- sub("/$","",working_directory)

  # set working directory to the one defined in the knit'ing R session
  setwd(working_directory)
}

# set knitr options as suggested by FK
opts_knit$set(width          = 150,
              self.contained = T
             )

# set code chunks options as suggested by FK
opts_chunk$set(comment    = NA,
               tidy       = F,
               highlight  = T,
               prompt     = T,
               fig.path   = paste(working_directory,"knitr/figures/",sep="/"),
               fig.keep   = "high",
               fig.show   = "asis",
               background = "#F5F5DC",
               echo       = F,
               cache      = F,
               cache.path = paste(working_directory,"knitr/cache/",sep="/"),
               message    = F,
               warning    = F,
               error      = F
              )

# adjust output format for inline code chunks to use a thousands separator
knit_hooks$set(inline = function(output) ifelse(is.numeric(output),prettyNum(output,big.mark=','),output))

# set non-knitr options in another code chunk as suggested by FK
```

```{r r_options,include=F,eval=T,cache=F}
#############
# R options #
#############

# set options as suggested by FK
options(width=150, digits=10)
options(stringsAsFactors=F)
```

```{r parameters,include=F,eval=T,cache=F}
##############
# parameters #
##############

# define default (absolute) path of TSV file with rating table (if not defined in the knit'ing R
# session)
if(!exists("table_tsv")) table_tsv<-paste0(working_directory,"/table.tsv")

# define default rating-to-score mapping (if not defined in the knit'ing R session)
if(!exists("rating2score")) rating2score<-c('---'=-3
                                           , '--'=-2
                                           ,  '-'=-1
                                           ,  '?'= 1
                                           ,  '+'= 2
                                           , '++'= 3
                                           ,'+++'= 5
                                           )


# define default rounding precision for numbers in output table (if not defined in the knit'ing R
# session)
if(!exists("digits.table")) digits.table<-2

# define default strptime format for date/time strings in input table (if not defined in the
# knit'ing R session)
if(!exists("format.datetime.input")) format.datetime.input<-"%F %R"

# define default strftime format for date/time strings in output table (if not defined in the
# knit'ing R session)
if(!exists("format.datetime.output")) format.datetime.output<-"%F %R"

# define default time zone (if not defined in the knit'ing R session)
if(!exists("timezone")) timezone<-"GMT"
```


```{r libraries,include=F,eval=T,cache=F}
#############
# libraries #
#############

# use efficient apply functions
require(plyr)


#############
# functions #
#############

# define each function in its own cached code chunk to allow dependence on those chunks to force
# re-evaluation of chached code chunks using the function in case the function gets modified.
```

```{r function.live_count2score,include=F,eval=T}
# calculate live score based on live count & rating score
live_count2score<-function(live_count,rating_score)
                    ifelse(rating_score>1
                          ,ifelse(live_count<6
                                 ,rating_score-live_count
                                 ,rating_score-sqrt(live_count-5)-5
                                 )
                          ,ifelse(rating_score<0
                                 ,(live_count-.5)*rating_score
                                 ,0
                                 )
                          )
```

```{r read_table}
##################
# get input data #
##################

# read table TSV
tab<-read.table(table_tsv,sep="\t",header=T,quote="\"",na.strings=c("","NA"))
```

```{r parse_datetime}
tab$start<-strptime(tab$start,format.datetime.input,timezone)
tab$end<-strptime(tab$end,format.datetime.input,timezone)
```

```{r remove_nas}
# replace missing ratings with '?'
rating.cols<-grep("rating.",colnames(tab),fixed=T,value=T)
tab[,rating.cols][is.na(tab[,rating.cols])]<-"?"

# get group members
members<-sub("rating.","",rating.cols)

# replace missing live counts with 0
live_count.cols<-paste0("live_count.",members)
tab[,live_count.cols][is.na(tab[,live_count.cols])]<-0
```

```{r untable}
# get bands
bands<-sort(unique(tab$band))

# identify first entry per band
bands.rows<-laply(bands,function(band) which(tab$band==band)[1])

# get ratings
ratings<-setNames(data.frame(tab[bands.rows,rating.cols],row.names=bands),members)

# get live counts
live_counts<-setNames(data.frame(tab[bands.rows,live_count.cols],row.names=bands),members)

# get gigs
gigs<-tab[order(tab$start),c("band","stage","start","end")]
```

```{r get_scores}
###############
# score bands #
###############

# get ratings scores
rating_scores<-data.frame(do.call(cbind
                                 ,llply(ratings
                                       ,'['
                                       ,x=rating2score
                                       )
                                 )
                         ,row.names=bands
                         )

# get live scores
live_scores<-setNames(data.frame(do.call(cbind
                                        ,llply(members
                                              ,function(member)
                                                  live_count2score(live_counts[,member]
                                                                  ,rating_scores[,member]
                                                                  )
                                              )
                                        )
                                ,row.names=bands
                                )
                     ,members
                     )

# get total scores
total_scores<-rating_scores+live_scores

# normalize scores
normalization.sums<-rowSums(total_scores)
scores<-(normalization.sums-min(normalization.sums))/(max(normalization.sums)-min(normalization.sums))


################
# write output #
################
```
# Festival schedule

## Lineup table

For now, the festival scheduler simply reproduces the spreadsheet table:

```{r print_table,result="asis"}
# assemble output table converting date/times to strings & scores to percent
tab<-with(gigs
         ,data.frame(band
                    ,setNames(ratings[band,],paste0("rating.",members))
                    ,setNames(live_counts[band,],paste0("live_count.",members))
                    ,score=paste0(round(scores[band],digits.table)*100,"%")
                    ,stage
                    ,start=strftime(start,format.datetime.output)
                    ,end=strftime(end,format.datetime.output)
                    )
         )

# replace missing values with "tbc"
tab[is.na(tab)]<-"tbc"

# print table sorted by score
kable(tab[order(scores[gigs$band]
               ,decreasing=T
               )
         ,
         ]
     ,digits=digits.table
     ,row.names=F
     )
```

```{r schedule}
# discard gigs with missing information
gigs<-gigs[!unlist(alply(gigs[,c("band","start","end")],1,anyNA)),]

# identify all time intervals with different gig combinations
times<-sort(with(gigs,c(start,end)))
intervals<-unique(ldply(1:sum(times<tail(times,1))
                       ,function(begin)
                          data.frame(interval.begin=times[begin]
                                    ,interval.end=times[times>times[begin]][1]
                                    )
                       )
                 )
# identify corresponding gigs
intervals<-alply(intervals
                ,1
                ,with
                ,list(interval.begin=interval.begin
                     ,interval.end=interval.end
                     ,interval.gigs=which(gigs$start<=interval.begin&gigs$end>=interval.end)
                     )
                )

# discard intervals without gigs
intervals<-intervals[llply(intervals,with,length(interval.gigs))!=0]

# order interval gigs by scores & add personal rankings
intervals<-llply(intervals
                ,with
                ,list(interval.begin=interval.begin
                     ,interval.end=interval.end
                     ,interval.gigs=interval.gigs[order(scores[gigs$band[interval.gigs]]
                                                       ,decreasing=T
                                                       )
                                                 ]
                     ,personal.gigs=setNames(do.call(data.frame
                                                    ,llply(members
                                                          ,function(member)
                                                              interval.gigs[order(total_scores[gigs$band[interval.gigs]
                                                                                              ,member
                                                                                              ]
                                                                                  ,decreasing=T
                                                                                  )
                                                                           ]
                                                          )
                                                    )
                                            ,members
                                            )
                     )
                )
```

## Running order

### Group running order

For now, only the group running oder is generated:

```{r print_running_order,result="asis",}
# select top scored band per interval
running_order<-ldply(intervals
                    ,with
                    ,data.frame(start=interval.begin
                               ,end=interval.end
                               ,interval.gig=interval.gigs[1]
                               ,band=gigs$band[interval.gigs][1]
                               ,stage=gigs$stage[interval.gigs][1]
                               )
                    ,.id=NULL
                    )

# merge intervals with same gig
running_order<-ddply(running_order
                    ,.(interval.gig)
                    ,with
                    ,data.frame(start=min(start)
                               ,end=max(end)
                               ,band=band[1]
                               ,stage=stage[1]
                               )
                    )

# print running order converting date/times to string & adding scores
kable(with(running_order
          ,data.frame(start=strftime(start,format.datetime.output)
                     ,end=strftime(end,format.datetime.output)
                     ,band
                     ,stage
                     ,score=paste0(round(scores[band],digits.table)*100,"%")
                     )
           )
     )
```

Note that the above running oder may still contain overlaps.
This can be happen if a short gig falls completely into a longer gig with lower score, that is the best scored gig in both intervals, before and after the shorter gig.
This is not intended and will be resolved in future versions.

```{r get.personal_running_orders}
# selet top scored band per group member & interval
personal_running_orders<-setNames(llply(members
                                       ,function(member){
                                          ldply(intervals
                                               ,function(interval)
                                                  with(interval
                                                      ,data.frame(start=interval.begin
                                                                 ,end=interval.end
                                                                 ,interval.gig=personal.gigs[1,member]
                                                                 ,band=gigs$band[personal.gigs[1,member]]
                                                                 ,stage=gigs$stage[personal.gigs[1,member]]
                                                                 )
                                                      )
                                               ,.id=NULL
                                               )
                                        }
                                       )
                                 ,members
                                 )

# merge intervals with same gig
personal_running_orders<-setNames(llply(members
                                 ,function(member)
                                    ddply(personal_running_orders[[member]]
                                         ,.(interval.gig)
                                         ,with
                                         ,data.frame(start=min(start)
                                                    ,end=max(end)
                                                    ,band=band[1]
                                                    ,stage=stage[1]
                                                    )
                                         )
                                 )
                           ,members
                           )
```

### Personal Running orders

```{r print.personal_running_orders,results="asis"}
# print running order for each member
l_ply(members
     ,function(member){

       # prepend running order with member name
       cat(paste0("\n#### ",member,"\n\n"))

       # print running order converting date/times to string & adding scores
       print(kable(with(personal_running_orders[[member]]
                     ,data.frame(start=strftime(start
                                               ,format.datetime.output
                                               )
                                ,end=strftime(end
                                             ,format.datetime.output
                                             )
                                ,band
                                ,stage
                                ,score=paste0(round(scores[band]
                                                   ,digits.table
                                                   )*100
                                             ,"%"
                                             )
                                )
                     )
                )
          )
      }
     )
```
